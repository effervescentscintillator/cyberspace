<!DOCTYPE html>
<html lang="en">

<head>
	<title>cyberspace</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="style.css">
</head>

<body>
	<div id="container"><div style="position:fixed; bottom:1px; background-color: lime; width: 0%; height: 1px;" id="loadingBar"></div></div>
	<script type="module">
		import { Ent } from '/ent.js';
		import { turn } from '/game.js';
		import * as THREE from 'three';
		import {OrbitControls} from 'three/examples/jsm/controls/OrbitControls.js';
		import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
		import WebGL from 'three/examples/jsm/capabilities/WebGL.js';
		import Stats from 'three/examples/jsm/libs/stats.module.js';
		import initJolt from 'https://www.unpkg.com/jolt-physics/dist/jolt-physics.wasm-compat.js';
		import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
		import GUI from 'lil-gui';
		import 'joypad.js'; 

// Graphics variables
var container, stats;
var camera, controls, scene, renderer;
var smoothCameraY = {translate:0,frames:0,inc:0};

// Timers
var past = 0;

// Physics variables
var jolt;
var physicsSystem;
var bodyInterface;

// List of objects spawned
var dynamicObjects = [];

// The update function
var onExampleUpdate


const DegreesToRadians = (deg) => deg * (Math.PI / 180.0);

const wrapVec3 = (v) => new THREE.Vector3(v.GetX(), v.GetY(), v.GetZ());
const unwrapVec3 = (v) => new Jolt.Vec3(v.x, v.y, v.z);
const wrapQuat = (q) => new THREE.Quaternion(q.GetX(), q.GetY(), q.GetZ(), q.GetW());
const unwrapQuat = (q) => new Jolt.Quat(q.x, q.y, q.z, q.w);

// Object layers
const LAYER_NON_MOVING = 0;
const LAYER_MOVING = 1;
const NUM_OBJECT_LAYERS = 2;

let analogMoveHorizontal = 0;
let analogMoveVertical = 0;
let analogLookHorizontal = 0;
let analogLookVertical = 0;
let euler = new THREE.Euler(0, 0, 0, "YXZ");
let jump = false;
let jumpReleased = true;
var movingTowardsGround;

var crouchEnabled = true;
var crouchHeight = 2;
var unCrouchHeight = 0;
var crouching = false;
var unCrouching = false;
var midAirFromCrouch = false;
var hasCrouched = false;

			var input = {
				forwardPressed: false,
				backwardPressed: false,
				leftPressed: false,
				rightPressed: false,
				crouched: false,
				d: 0,
				lastMouseMove: performance.now(),
				MouseMoveX: 0,
				vector: {x:0,z:0},
				collision: {x:0,y:0,z:0},
				init: true,
				contacts: [],
				knockBackDir: new THREE.Vector3(0,0,0)
			};

function getRandomQuat() {
	let vec = new Jolt.Vec3(0.001 + Math.random(), Math.random(), Math.random());
	let quat = Jolt.Quat.prototype.sRotation(vec.Normalized(), 2 * Math.PI * Math.random());
	Jolt.destroy(vec);
	return quat;
}

function onWindowResize() {

	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();

	renderer.setSize(window.innerWidth, window.innerHeight);
}

function initGraphics() {

	renderer = new THREE.WebGLRenderer();
	renderer.setClearColor(0xbfd1e5);
	renderer.setPixelRatio(window.devicePixelRatio);
	renderer.setSize(window.innerWidth, window.innerHeight);

	camera = new THREE.PerspectiveCamera(90, window.innerWidth / window.innerHeight, 0.2, 2000);
	camera.position.set(0, 2, 0);
	camera.lookAt(new THREE.Vector3(0, 2, 0));

	scene = new THREE.Scene();

	var dirLight = new THREE.DirectionalLight(0xffffff, 1);
	dirLight.position.set(10, 10, 5);
	scene.add(dirLight);

	container.appendChild(renderer.domElement);

	stats = new Stats();
	stats.domElement.style.position = 'absolute';
	stats.domElement.style.top = '0px';
	stats.domElement.style.opacity = '.6';
	container.appendChild(stats.domElement);

	window.addEventListener('resize', onWindowResize, false);
}

let setupCollisionFiltering = function (settings) {
	// Layer that objects can be in, determines which other objects it can collide with
	// Typically you at least want to have 1 layer for moving bodies and 1 layer for static bodies, but you can have more
	// layers if you want. E.g. you could have a layer for high detail collision (which is not used by the physics simulation
	// but only if you do collision testing).
	let objectFilter = new Jolt.ObjectLayerPairFilterTable(NUM_OBJECT_LAYERS);
	objectFilter.EnableCollision(LAYER_NON_MOVING, LAYER_MOVING);
	objectFilter.EnableCollision(LAYER_MOVING, LAYER_MOVING);

	// Each broadphase layer results in a separate bounding volume tree in the broad phase. You at least want to have
	// a layer for non-moving and moving objects to avoid having to update a tree full of static objects every frame.
	// You can have a 1-on-1 mapping between object layers and broadphase layers (like in this case) but if you have
	// many object layers you'll be creating many broad phase trees, which is not efficient.
	const BP_LAYER_NON_MOVING = new Jolt.BroadPhaseLayer(0);
	const BP_LAYER_MOVING = new Jolt.BroadPhaseLayer(1);
	const NUM_BROAD_PHASE_LAYERS = 2;
	let bpInterface = new Jolt.BroadPhaseLayerInterfaceTable(NUM_OBJECT_LAYERS, NUM_BROAD_PHASE_LAYERS);
	bpInterface.MapObjectToBroadPhaseLayer(LAYER_NON_MOVING, BP_LAYER_NON_MOVING);
	bpInterface.MapObjectToBroadPhaseLayer(LAYER_MOVING, BP_LAYER_MOVING);

	settings.mObjectLayerPairFilter = objectFilter;
	settings.mBroadPhaseLayerInterface = bpInterface;
	settings.mObjectVsBroadPhaseLayerFilter = new Jolt.ObjectVsBroadPhaseLayerFilterTable(settings.mBroadPhaseLayerInterface, NUM_BROAD_PHASE_LAYERS, settings.mObjectLayerPairFilter, NUM_OBJECT_LAYERS);
};

function initPhysics() {

	// Initialize Jolt
	let settings = new Jolt.JoltSettings();
	setupCollisionFiltering(settings);
	jolt = new Jolt.JoltInterface(settings);
	Jolt.destroy(settings);
	physicsSystem = jolt.GetPhysicsSystem();
	bodyInterface = physicsSystem.GetBodyInterface();

	// Helper functions
	Jolt.Vec3.prototype.ToString = function () { return `(${this.GetX()}, ${this.GetY()}, ${this.GetZ()})` };
	Jolt.Vec3.prototype.Clone = function () { return new Jolt.Vec3(this.GetX(), this.GetY(), this.GetZ()); };
	Jolt.Quat.prototype.ToString = function () { return `(${this.GetX()}, ${this.GetY()}, ${this.GetZ()}, ${this.GetW()})` };
	Jolt.Quat.prototype.Clone = function () { return new Jolt.Vec3(this.GetX(), this.GetY(), this.GetZ(), this.GetW()); };
	Jolt.AABox.prototype.ToString = function () { return `[${this.mMax.ToString()}, ${this.mMin.ToString()}]`; };
}

function updatePhysics(deltaTime) {

	var numSteps = 1;

	// Step the physics world
	jolt.Step(deltaTime, numSteps);
}

function initExample(Jolt, updateFunction) {
	window.Jolt = Jolt;

	container = document.getElementById('container');

	if (WebGL.isWebGLAvailable()) {
		onExampleUpdate = updateFunction;

		initGraphics();
		initPhysics();
		renderer.xr.enable = true;
		renderer.setAnimationLoop(renderExample);
	} else {
		const warning = WebGL.getWebGLErrorMessage();
		container.appendChild(warning);
	}

	// The memory profiler doesn't have an ID so we can't mess with it in css, set an ID here
	let memoryprofilerCanvas = document.getElementById("memoryprofiler_canvas");
	if (memoryprofilerCanvas)
		memoryprofilerCanvas.parentElement.id = "memoryprofiler";
}

function renderExample(time) {
	// Don't go below 60 Hz to prevent spiral of death
	var deltaTime =  (time - past) / 1000;
		past=time;

	deltaTime = Math.min(deltaTime, 1.0 / 60.0);
	if(deltaTime == 0){deltaTime = .000001;}
	if (onExampleUpdate != null)
		onExampleUpdate(time, deltaTime);

	// Update object transforms
	for (let i = 0, il = dynamicObjects.length; i < il; i++) {
		let objThree = dynamicObjects[i];
		let body = objThree.userData.body;
		objThree.position.copy(wrapVec3(body.GetPosition()));
		objThree.quaternion.copy(wrapQuat(body.GetRotation()));

		if (body.GetBodyType() == Jolt.EBodyType_SoftBody)
			objThree.geometry = createMeshForShape(body.GetShape());
	}

	updatePhysics(deltaTime);

	renderer.render(scene, camera);

	stats.update();

}

function addToThreeScene(body, color) {
	let threeObject = getThreeObjectForBody(body, color);
	threeObject.userData.body = body;

	scene.add(threeObject);
	dynamicObjects.push(threeObject);
}

function addToScene(body, color) {
	bodyInterface.AddBody(body.GetID(), Jolt.EActivation_Activate);

	addToThreeScene(body, color);
}

function removeFromScene(threeObject) {
	let id = threeObject.userData.body.GetID();
	bodyInterface.RemoveBody(id);
	bodyInterface.DestroyBody(id);
	delete threeObject.userData.body;

	scene.remove(threeObject);
	let idx = dynamicObjects.indexOf(threeObject);
	dynamicObjects.splice(idx, 1);
}

function createFloor(size = 50) {
	var shape = new Jolt.BoxShape(new Jolt.Vec3(size, 0.5, size), 0.05, null);
	var creationSettings = new Jolt.BodyCreationSettings(shape, new Jolt.Vec3(0, -0.5, 0), new Jolt.Quat(0, 0, 0, 1), Jolt.EMotionType_Static, LAYER_NON_MOVING);
	let body = bodyInterface.CreateBody(creationSettings);
	Jolt.destroy(creationSettings);
	addToScene(body, 0xc7c7c7);
	return body;
}

function createBox(position, rotation, halfExtent, motionType, layer, color = 0xffffff) {
	let shape = new Jolt.BoxShape(halfExtent, 0.05, null);
	let creationSettings = new Jolt.BodyCreationSettings(shape, position, rotation, motionType, layer);
	let body = bodyInterface.CreateBody(creationSettings);
	Jolt.destroy(creationSettings);
	addToScene(body, color);
	return body;
}

function createSphere(position, radius, motionType, layer, color = 0xffffff) {
	let shape = new Jolt.SphereShape(radius, null);
	let creationSettings = new Jolt.BodyCreationSettings(shape, position, Jolt.Quat.prototype.sIdentity(), motionType, layer);
	let body = bodyInterface.CreateBody(creationSettings);
	Jolt.destroy(creationSettings);
	addToScene(body, color);
	return body;
}

function createMeshForShape(shape) {
	// Get triangle data
	let scale = new Jolt.Vec3(1, 1, 1);
	let triContext = new Jolt.ShapeGetTriangles(shape, Jolt.AABox.prototype.sBiggest(), shape.GetCenterOfMass(), Jolt.Quat.prototype.sIdentity(), scale);
	Jolt.destroy(scale);

	// Get a view on the triangle data (does not make a copy)
	let vertices = new Float32Array(Jolt.HEAPF32.buffer, triContext.GetVerticesData(), triContext.GetVerticesSize() / Float32Array.BYTES_PER_ELEMENT);

	// Now move the triangle data to a buffer and clone it so that we can free the memory from the C++ heap (which could be limited in size)
	let buffer = new THREE.BufferAttribute(vertices, 3).clone();
	Jolt.destroy(triContext);

	// Create a three mesh
	let geometry = new THREE.BufferGeometry();
	geometry.setAttribute('position', buffer);
	geometry.computeVertexNormals();

	return geometry;
}

function getThreeObjectForBody(body, color) {
	let material = new THREE.MeshPhongMaterial({ color: color });


	let threeObject;
	let shape = body.GetShape();
	switch (shape.GetSubType()) {
		case Jolt.EShapeSubType_Box:
			let boxShape = Jolt.castObject(shape, Jolt.BoxShape);
			let extent = wrapVec3(boxShape.GetHalfExtent()).multiplyScalar(2);
			threeObject = new THREE.Mesh(new THREE.BoxGeometry(extent.x, extent.y, extent.z, 1, 1, 1), material);
			break;
		case Jolt.EShapeSubType_Sphere:
			let sphereShape = Jolt.castObject(shape, Jolt.SphereShape);
			threeObject = new THREE.Mesh(new THREE.SphereGeometry(sphereShape.GetRadius(), 32, 32), material);
			break;
		case Jolt.EShapeSubType_Capsule:
			let capsuleShape = Jolt.castObject(shape, Jolt.CapsuleShape);
			threeObject = new THREE.Mesh(new THREE.CapsuleGeometry(capsuleShape.GetRadius(), 2 * capsuleShape.GetHalfHeightOfCylinder(), 20, 10), material);
			break;
		case Jolt.EShapeSubType_Cylinder:
			let cylinderShape = Jolt.castObject(shape, Jolt.CylinderShape);
			threeObject = new THREE.Mesh(new THREE.CylinderGeometry(cylinderShape.GetRadius(), cylinderShape.GetRadius(), 2 * cylinderShape.GetHalfHeight(), 20, 1), material);
			break;
		default:
			threeObject = new THREE.Mesh(createMeshForShape(shape), material);
			break;
	}

	threeObject.position.copy(wrapVec3(body.GetPosition()));
	threeObject.quaternion.copy(wrapQuat(body.GetRotation()));

	return threeObject;
}

function createVehicleTrack() {
	const track = [
		[[[38, 64, -14], [38, 64, -16], [38, -64, -16], [38, -64, -14], [64, -64, -16], [64, -64, -14], [64, 64, -16], [64, 64, -14]], [[-16, 64, -14], [-16, 64, -16], [-16, -64, -16], [-16, -64, -14], [10, -64, -16], [10, -64, -14], [10, 64, -16], [10, 64, -14]], [[10, -48, -14], [10, -48, -16], [10, -64, -16], [10, -64, -14], [38, -64, -16], [38, -64, -14], [38, -48, -16], [38, -48, -14]], [[10, 64, -14], [10, 64, -16], [10, 48, -16], [10, 48, -14], [38, 48, -16], [38, 48, -14], [38, 64, -16], [38, 64, -14]]],
		[[[38, 48, -10], [38, 48, -14], [38, -48, -14], [38, -48, -10], [40, -48, -14], [40, -48, -10], [40, 48, -14], [40, 48, -10]], [[62, 62, -10], [62, 62, -14], [62, -64, -14], [62, -64, -10], [64, -64, -14], [64, -64, -10], [64, 62, -14], [64, 62, -10]], [[8, 48, -10], [8, 48, -14], [8, -48, -14], [8, -48, -10], [10, -48, -14], [10, -48, -10], [10, 48, -14], [10, 48, -10]], [[-16, 62, -10], [-16, 62, -14], [-16, -64, -14], [-16, -64, -10], [-14, -64, -14], [-14, -64, -10], [-14, 62, -14], [-14, 62, -10]], [[-14, -62, -10], [-14, -62, -14], [-14, -64, -14], [-14, -64, -10], [62, -64, -14], [62, -64, -10], [62, -62, -14], [62, -62, -10]], [[8, -48, -10], [8, -48, -14], [8, -50, -14], [8, -50, -10], [40, -50, -14], [40, -50, -10], [40, -48, -14], [40, -48, -10]], [[8, 50, -10], [8, 50, -14], [8, 48, -14], [8, 48, -10], [40, 48, -14], [40, 48, -10], [40, 50, -14], [40, 50, -10]], [[-16, 64, -10], [-16, 64, -14], [-16, 62, -14], [-16, 62, -10], [64, 62, -14], [64, 62, -10], [64, 64, -14], [64, 64, -10]]],
		[[[-4, 22, -14], [-4, -14, -14], [-4, -14, -10], [4, -14, -14], [4, -14, -10], [4, 22, -14]], [[-4, -27, -14], [-4, -48, -14], [-4, -48, -11], [4, -48, -14], [4, -48, -11], [4, -27, -14]], [[-4, 50, -14], [-4, 30, -14], [-4, 30, -12], [4, 30, -14], [4, 30, -12], [4, 50, -14]], [[46, 50, -14], [46, 31, -14], [46, 50, -12], [54, 31, -14], [54, 50, -12], [54, 50, -14]], [[46, 16, -14], [46, -19, -14], [46, 16, -10], [54, -19, -14], [54, 16, -10], [54, 16, -14]], [[46, -28, -14], [46, -48, -14], [46, -28, -11], [54, -48, -14], [54, -28, -11], [54, -28, -14]]]
	];

	const mapColors = [0x666666, 0x006600, 0x000066];

	let tempVec = new Jolt.Vec3(0, 1, 0);
	const mapRot = Jolt.Quat.prototype.sRotation(tempVec, 0.5 * Math.PI);
	track.forEach((type, tIdx) => {
		type.forEach(block => {
			const hull = new Jolt.ConvexHullShapeSettings;
			block.forEach(v => {
				tempVec.Set(-v[1], v[2], v[0]);
				hull.mPoints.push_back(tempVec);
			});
			const shape = hull.Create().Get();
			tempVec.Set(0, 10, 0);
			const creationSettings = new Jolt.BodyCreationSettings(shape, tempVec, mapRot, Jolt.EMotionType_Static, LAYER_NON_MOVING);
			Jolt.destroy(hull);
			const body = bodyInterface.CreateBody(creationSettings);
			Jolt.destroy(creationSettings);
			body.SetFriction(1.0);
			addToScene(body, mapColors[tIdx]);
		});
	});
	Jolt.destroy(tempVec);
}

function addLine(from, to, color) {
	const material = new THREE.LineBasicMaterial({ color: color });
	const points = [];
	points.push(wrapVec3(from));
	points.push(wrapVec3(to));
	const geometry = new THREE.BufferGeometry().setFromPoints(points);
	const line = new THREE.Line(geometry, material);
	scene.add(line);
}

function addMarker(location, size, color) {
	const material = new THREE.LineBasicMaterial({ color: color });
	const points = [];
	const center = wrapVec3(location);
	points.push(center.clone().add(new THREE.Vector3(-size, 0, 0)));
	points.push(center.clone().add(new THREE.Vector3(size, 0, 0)));
	points.push(center.clone().add(new THREE.Vector3(0, -size, 0)));
	points.push(center.clone().add(new THREE.Vector3(0, size, 0)));
	points.push(center.clone().add(new THREE.Vector3(0, 0, -size)));
	points.push(center.clone().add(new THREE.Vector3(0, 0, size)));
	const geometry = new THREE.BufferGeometry().setFromPoints(points);
	const line = new THREE.LineSegments(geometry, material);
	scene.add(line);
}




		const loader = new GLTFLoader();
		let vertices = 0;
		let indeces = 0;

		initJolt().then(function (Jolt) {

			loader.load(
		      'map.glb',
      		  // called when the resource is loaded
    		  function ( gltf ) {
        	  initExample(Jolt, null);
        	  
        	    scene.add( gltf.scene );

        	let vertex = gltf.scene.children[0].geometry.attributes.position;
				  let index = gltf.scene.children[0].geometry.index;
				  let j, i, ref;

				  let triangles = new Jolt.TriangleList();

				  for (i = j = 0, ref = index.count /  3; (0 <= ref ? j < ref : j > ref); i = 0 <= ref ? ++j : --j) {
  				  triangles.push_back(new Jolt.Triangle(
 					  new Jolt.Vec3(vertex.getX(index.getX(i*3)), vertex.getY(index.getX(i*3)), vertex.getZ(index.getX(i*3))),
 					  new Jolt.Vec3(vertex.getX(index.getY(i*3)), vertex.getY(index.getY(i*3)), vertex.getZ(index.getY(i*3))),
 					  new Jolt.Vec3(vertex.getX(index.getZ(i*3)), vertex.getY(index.getZ(i*3)), vertex.getZ(index.getZ(i*3)))
				    ));
				  }

					let shape = new Jolt.MeshShapeSettings(triangles).Create().Get();
					Jolt.destroy(triangles);

					// Create body
					let creationSettings = new Jolt.BodyCreationSettings(shape, new Jolt.Vec3(0, 0, 0), new Jolt.Quat(0, 0, 0, 1), Jolt.EMotionType_Static, LAYER_NON_MOVING);
					let body = bodyInterface.CreateBody(creationSettings);
					Jolt.destroy(creationSettings);
					bodyInterface.AddBody(body.GetID(), Jolt.EActivation_Activate);

        	    gltf.animations; // Array<THREE.AnimationClip>
        	    gltf.scene; // THREE.Group
        	    gltf.scenes; // Array<THREE.Group>
        	    gltf.cameras; // Array<THREE.Camera>
        	    gltf.asset; // Object

        	  setup();
      	  },
    		  // called while loading is progressing
    		  function ( xhr ) {
    		  	var loadingBar = document.getElementById('loadingBar');
    		  	loadingBar.style.width = Math.round(xhr.loaded / xhr.total * 100) + "%";
    		  	if(Math.round(xhr.loaded / xhr.total * 100) == 100){
    		  		loadingBar.style.display = "none";
    		  	}
     		 },
    		  // called when loading has errors
    		  function ( error ) {

    		    console.log( 'An error happened' );

    		  }
    		);

			// Initialize this example
			var setup = function(){
			const characterHeightStanding = 1;
			const characterRadiusStanding = .59;
			const characterHeightCrouching = .5;
			const characterRadiusCrouching = .59;

			// Character movement properties
			const controlMovementDuringJump = true;					///< If false the character cannot change movement direction in mid air
			const characterSpeed = 6.0;
			const jumpSpeed = 10.0;

			const enableCharacterInertia = true;

			const upRotationX = 0;
			const upRotationZ = 0;
			const maxSlopeAngle = DegreesToRadians(45.0);
			const maxStrength = 100.0;
			const characterPadding = 0.02;
			const penetrationRecoverySpeed = 1.0;
			const predictiveContactDistance = 0.1;
			const enableWalkStairs = true;
			let enableStickToFloor = true;

			let init = false;
			let shapeType = 'Box';
			let standingShape;
			let crouchingShape;
			let threeStandingGeometry;
			let threeCrouchingGeometry;

			let character;
			let isCrouched = false;
			let allowSliding = false;

			const geometry = new THREE.BoxGeometry(1, 1, 1);
			const material = new THREE.MeshPhongMaterial({ color: 0xffff00, opacity: 0 });
			let threeCharacter = new THREE.Mesh(geometry, material);
			threeCharacter.material.transparent = true ;
			let desiredVelocity = new THREE.Vector3();

			const updateSettings = new Jolt.ExtendedUpdateSettings();

			const objectVsBroadPhaseLayerFilter = jolt.GetObjectVsBroadPhaseLayerFilter();
			const objectLayerPairFilter = jolt.GetObjectLayerPairFilter();

			const movingBPFilter = new Jolt.DefaultBroadPhaseLayerFilter(objectVsBroadPhaseLayerFilter, LAYER_MOVING);
			const movingLayerFilter = new Jolt.DefaultObjectLayerFilter(objectLayerPairFilter, LAYER_MOVING);
			const bodyFilter = new Jolt.BodyFilter();
			const shapeFilter = new Jolt.ShapeFilter();

			const initShape = () => {
				const positionStanding = new Jolt.Vec3(0, 0.5 * characterHeightStanding + characterRadiusStanding, 0);
				const positionCrouching = new Jolt.Vec3(0, 0.5 * characterHeightCrouching + characterRadiusCrouching, 0);
				const rotation = Jolt.Quat.prototype.sIdentity();

				switch (shapeType) {
					case 'Capsule':
						standingShape = new Jolt.RotatedTranslatedShapeSettings(positionStanding, rotation, new Jolt.CapsuleShapeSettings(0.5 * characterHeightStanding, characterRadiusStanding)).Create().Get();
						crouchingShape = new Jolt.RotatedTranslatedShapeSettings(positionCrouching, rotation, new Jolt.CapsuleShapeSettings(0.5 * characterHeightCrouching, characterRadiusCrouching)).Create().Get();

						threeStandingGeometry = new THREE.CapsuleGeometry(characterRadiusStanding, characterHeightStanding, 4, 8).translate(0, 0.5 * characterHeightStanding + characterRadiusStanding, 0);
						threeCrouchingGeometry = new THREE.CapsuleGeometry(characterRadiusCrouching, characterHeightCrouching, 4, 8).translate(0, 0.5 * characterHeightCrouching + characterRadiusCrouching, 0);
						break;

					case 'Cylinder':
						standingShape = new Jolt.RotatedTranslatedShapeSettings(positionStanding, rotation, new Jolt.CylinderShapeSettings(0.5 * characterHeightStanding + characterRadiusStanding, characterRadiusStanding)).Create().Get();
						crouchingShape = new Jolt.RotatedTranslatedShapeSettings(positionCrouching, rotation, new Jolt.CylinderShapeSettings(0.5 * characterHeightCrouching + characterRadiusCrouching, characterRadiusCrouching)).Create().Get();

						threeStandingGeometry = new THREE.CylinderGeometry(characterRadiusStanding, characterRadiusStanding, 2 * characterRadiusStanding + characterHeightStanding, 8, 4).translate(0, 0.5 * characterHeightStanding + characterRadiusStanding, 0);
						threeCrouchingGeometry = new THREE.CylinderGeometry(characterRadiusCrouching, characterRadiusCrouching, 2 * characterRadiusCrouching + characterHeightCrouching, 8, 4).translate(0, 0.5 * characterHeightCrouching + characterRadiusCrouching, 0);
						break;

					case 'Box':
						standingShape = new Jolt.RotatedTranslatedShapeSettings(positionStanding, rotation, new Jolt.BoxShapeSettings(new Jolt.Vec3(characterRadiusStanding, 0.5 * characterHeightStanding + characterRadiusStanding, characterRadiusStanding))).Create().Get();
						crouchingShape = new Jolt.RotatedTranslatedShapeSettings(positionCrouching, rotation, new Jolt.BoxShapeSettings(new Jolt.Vec3(characterRadiusCrouching, 0.5 * characterHeightCrouching + characterRadiusCrouching, characterRadiusCrouching))).Create().Get();

						threeStandingGeometry = new THREE.BoxGeometry(2 * characterRadiusStanding, 2 * characterRadiusStanding + characterHeightStanding, 2 * characterRadiusStanding).translate(0, 0.5 * characterHeightStanding + characterRadiusStanding, 0);
						threeCrouchingGeometry = new THREE.BoxGeometry(2 * characterRadiusCrouching, 2 * characterRadiusCrouching + characterHeightCrouching, 2 * characterRadiusCrouching).translate(0, 0.5 * characterHeightCrouching + characterRadiusCrouching, 0);
						break;
				}
			}

			const lavaObject = createBox(new Jolt.Vec3(0, -50, 0), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(1000, 2, 1000), Jolt.EMotionType_Static, LAYER_NON_MOVING, 0xcc2222);
			const lavaObjectId = lavaObject.GetID().GetIndexAndSequenceNumber();
			let isInLava = false;

			const conveyorBeltObject = createBox(new Jolt.Vec3(0, 0, -10), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(10, 0.25, 2), Jolt.EMotionType_Static, LAYER_NON_MOVING, 0x2222cc);
			const conveyorBeltObjectId = conveyorBeltObject.GetID().GetIndexAndSequenceNumber();

			    const contactListener = new Jolt.ContactListenerJS();
    contactListener.OnContactValidate = (body1, body2, baseOffset, collideShapeResult) => {
          console.log('aaab3');
          body1 = Jolt.wrapPointer(body1, Jolt.Body);
          body2 = Jolt.wrapPointer(body2, Jolt.Body);
          collideShapeResult = Jolt.wrapPointer(collideShapeResult, Jolt.CollideShapeResult);
          return Jolt.ValidateResult_AcceptAllContactsForThisBodyPair;
    };
    contactListener.OnContactAdded = (body1, body2, manifold, settings) => {
                console.log('aaa2c3');

          body1 = Jolt.wrapPointer(body1, Jolt.Body);
          body2 = Jolt.wrapPointer(body2, Jolt.Body);
          manifold = Jolt.wrapPointer(manifold, Jolt.ContactManifold);
          settings = Jolt.wrapPointer(settings, Jolt.ContactSettings);
          console.log(body1.GetID().GetIndex() + ' ' + body2.GetID().GetIndex() + ' ' + manifold.mWorldSpaceNormal.ToString());
          input.contacts.push({
          	body1: body1,
          	body2: body2,
          	manifold: manifold,
          	settings: settings
          });
          // Override the restitution to 0.5
          settings.mCombinedRestitution = 0.5;
    };
		contactListener.OnContactPersisted = (body1, body2, manifold, settings) => {
					body1 = Jolt.wrapPointer(body1, Jolt.Body);
					body2 = Jolt.wrapPointer(body2, Jolt.Body);
					manifold = Jolt.wrapPointer(manifold, Jolt.ContactManifold);
					settings = Jolt.wrapPointer(settings, Jolt.ContactSettings);
					//collisionLog.value += 'OnContactPersisted ' + body1.GetID().GetIndex() + ' ' + body2.GetID().GetIndex() + ' ' + manifold.mWorldSpaceNormal.ToString() + '\n';

					// Override the restitution to 0.5
					settings.mCombinedRestitution = 0.5;
				};
		contactListener.OnContactRemoved = (subShapePair) => {
					subShapePair = Jolt.wrapPointer(subShapePair, Jolt.SubShapeIDPair);
					//collisionLog.value += 'OnContactRemoved ' + subShapePair.GetBody1ID().GetIndex() + ' ' + subShapePair.GetBody2ID().GetIndex() + '\n';
		};
    physicsSystem.SetContactListener(contactListener);

			const characterContactListener = new Jolt.CharacterContactListenerJS();
			characterContactListener.OnAdjustBodyVelocity = (character, body2, linearVelocity, angularVelocity) => {
				body2 = Jolt.wrapPointer(body2, Jolt.Body);
				linearVelocity = Jolt.wrapPointer(linearVelocity, Jolt.Vec3);
				// Apply artificial velocity to the character when standing on the conveyor belt
				if (body2.GetID().GetIndexAndSequenceNumber() == conveyorBeltObjectId) {
					linearVelocity.SetX(linearVelocity.GetX() + 5);
				}
			}
			characterContactListener.OnContactValidate = (character, bodyID2, subShapeID2) => {
				bodyID2 = Jolt.wrapPointer(bodyID2, Jolt.BodyID);
				character = Jolt.wrapPointer(character, Jolt.CharacterVirtual);
				if (bodyID2.GetIndexAndSequenceNumber() == lavaObjectId)
					isInLava = true; // Can't modify velocity or position at this point, marking that we want to teleport
				return true;
			}
			characterContactListener.OnContactAdded = (character, bodyID2, subShapeID2, contactPosition, contactNormal, settings) => {
			}
			characterContactListener.OnContactSolve = (character, bodyID2, subShapeID2, contactPosition, contactNormal, contactVelocity, contactMaterial, characterVelocity, newCharacterVelocity) => {
				// Don't allow the player to slide down static not-too-steep surfaces when not actively moving and when not on a moving platform
				character = Jolt.wrapPointer(character, Jolt.CharacterVirtual);
				contactVelocity = Jolt.wrapPointer(contactVelocity, Jolt.Vec3);
				newCharacterVelocity = Jolt.wrapPointer(newCharacterVelocity, Jolt.Vec3);
				contactNormal = Jolt.wrapPointer(contactNormal, Jolt.Vec3);
				if (!allowSliding && contactVelocity.IsNearZero() && !character.IsSlopeTooSteep(contactNormal)) {
					newCharacterVelocity.SetX(0);
					newCharacterVelocity.SetY(0);
					newCharacterVelocity.SetZ(0);
				}
			}

			const _tmpVec3 = new Jolt.Vec3();
			const prePhysicsUpdate = (deltaTime) => {
				if (isInLava) {
					// Teleport the user back to the origin if they fall off the platform
					_tmpVec3.Set(0, 10, 0);
					character.SetPosition(_tmpVec3);
					isInLava = false;
					input.reset = true;
				}
				const characterUp = wrapVec3(character.GetUp());
				if (!enableStickToFloor) {
					updateSettings.mStickToFloorStepDown = Jolt.Vec3.prototype.sZero();
				} else {
					const vec = characterUp.clone().multiplyScalar(-updateSettings.mStickToFloorStepDown.Length());
					updateSettings.mStickToFloorStepDown.Set(vec.x, vec.y, vec.z);
				}

				if (!enableWalkStairs) {
					updateSettings.mWalkStairsStepUp = Jolt.Vec3.prototype.sZero();
				} else {
					const vec = characterUp.clone().multiplyScalar(updateSettings.mWalkStairsStepUp.Length());
					updateSettings.mWalkStairsStepUp.Set(vec.x, vec.y, vec.z);
				}
				characterUp.multiplyScalar(-physicsSystem.GetGravity().Length());
				character.ExtendedUpdate(deltaTime,
					character.GetUp(),
					updateSettings,
					movingBPFilter,
					movingLayerFilter,
					bodyFilter,
					shapeFilter,
					jolt.GetTempAllocator());

				threeCharacter.position.copy(wrapVec3(character.GetPosition()));
			}

			const handleInput = (movementDirection, switchStance,inputCollisionY, deltaTime) => {
				const playerControlsHorizontalVelocity = controlMovementDuringJump || character.IsSupported();
				if (playerControlsHorizontalVelocity) {
					// True if the player intended to move
					allowSliding = true;
					// Smooth the player input
					if (enableCharacterInertia) {
						desiredVelocity.multiplyScalar(0.75).add(movementDirection.multiplyScalar(0.25 * characterSpeed))
					} else {
						desiredVelocity.copy(movementDirection).multiplyScalar(characterSpeed);
					}
				} else {
					// While in air we allow sliding
					allowSliding = true;
				}
				_tmpVec3.Set(upRotationX, 0, upRotationZ);
				const characterUpRotation = Jolt.Quat.prototype.sEulerAngles(_tmpVec3);
				character.SetUp(characterUpRotation.RotateAxisY());
				character.SetRotation(characterUpRotation);
				const upRotation = wrapQuat(characterUpRotation);

				character.UpdateGroundVelocity();
				const characterUp = wrapVec3(character.GetUp());
				const linearVelocity = wrapVec3(character.GetLinearVelocity());
				const currentVerticalVelocity = characterUp.clone().multiplyScalar(linearVelocity.dot(characterUp));
				const groundVelocity = wrapVec3(character.GetGroundVelocity());
				const gravity = wrapVec3(physicsSystem.GetGravity());

				var newVelocity;
				movingTowardsGround = (currentVerticalVelocity.y - groundVelocity.y) < 0.1;
				if (character.GetGroundState() == Jolt.EGroundState_OnGround					// If on ground
					&& (enableCharacterInertia ?
						movingTowardsGround													// Inertia enabled: And not moving away from ground
						: !character.IsSlopeTooSteep(character.GetGroundNormal())))			// Inertia disabled: And not on a slope that is too steep
				{
					// Assume velocity of ground when on ground
					newVelocity = groundVelocity;
					if(input.grounded){midAirFromCrouch = false;}
					// Jump
					if (jump && movingTowardsGround && jumpReleased){
						newVelocity.add(characterUp.multiplyScalar(jumpSpeed));
						midAirFromCrouch = false;
					}
					if (!jump){jumpReleased = true;}
				} else {
					if(input.crouched){console.log(midAirFromCrouch + ' ' + jump + ' ' + movingTowardsGround);}
					if (midAirFromCrouch && jump && movingTowardsGround && jumpReleased){
						console.log('jmp');
						newVelocity = groundVelocity;
						newVelocity.add(characterUp.multiplyScalar(jumpSpeed - .5));
						midAirFromCrouch = false;
					} else {
						newVelocity = currentVerticalVelocity.clone();
					}
				}
				if(input.knockBackDir.y !== 0){
					newVelocity.add(characterUp.multiplyScalar(input.knockBackDir.y * input.knockBackMultiplier * 10));
					input.knockBackDir.setY(0);
					midAirFromCrouch = false;
				}
				//newVelocity.add(input.knockBackDir.y / 10000);
				// Gravity
				newVelocity.add(gravity.multiplyScalar(deltaTime).applyQuaternion(upRotation));
				if (playerControlsHorizontalVelocity) {
					// Player input
					newVelocity.add(new THREE.Vector3(players[0].translation.x *100, players[0].translation.y *100, players[0].translation.z *100));
				} else {
					// Preserve horizontal velocity
					const currentHorizontalVelocity = linearVelocity.sub(currentVerticalVelocity);
					newVelocity.add(currentHorizontalVelocity);
				}
				_tmpVec3.Set(newVelocity.x, newVelocity.y, newVelocity.z);
				character.SetLinearVelocity(_tmpVec3);
			}
			var uncrouchBlock = false;
			const setCrouched = (crouched, forceUpdate) => {

				if (crouched != isCrouched || forceUpdate || uncrouchBlock) {
					let newShape;
					let newGeometry;
					if (crouched) {
						newShape = crouchingShape;
						newGeometry = threeCrouchingGeometry;
						crouchHeight = 2;
						unCrouchHeight = 0;
						crouching = true;
					} else {
						newShape = standingShape;
						newGeometry = threeStandingGeometry;
						crouchHeight = 1;
						crouching = false;
					}
					if (character.SetShape(newShape,
						1.5 * physicsSystem.GetPhysicsSettings().mPenetrationSlop,
						movingBPFilter,
						movingLayerFilter,
						bodyFilter,
						shapeFilter,
						jolt.GetTempAllocator())) {
						
						// Accept the new shape only when the SetShape call was successful
						isCrouched = crouched;
						threeCharacter.geometry = newGeometry;
						camera.position.set(camera.position.x, threeCharacter.position.y + crouchHeight, camera.position.z);
						if(crouching && !hasCrouched){
							if(!midAirFromCrouch){
								if (input.grounded){midAirFromCrouch = true; input.grounded = false;}
						  _tmpVec3.Set(
						  	threeCharacter.position.x,
						   	threeCharacter.position.y + 1,
						    threeCharacter.position.z
						  );
					    character.SetPosition(_tmpVec3);
							}
							crouching = false;
							hasCrouched = true;
					   } else {
							unCrouchHeight = 0.1;
							hasCrouched = false;
						}
					}
				}
			}

			// Stairs
			for (let j = 0; j < 5; j++) {
				let stepHeight = 0.3 + 0.1 * j;
				for (let i = 1; i < 10; i++) {
					createBox(new Jolt.Vec3(15 + 5 * j, i * stepHeight - 0.5 + stepHeight / 2, -20 - i * 3), Jolt.Quat.prototype.sIdentity(), new Jolt.Vec3(2, stepHeight / 2, 2), Jolt.EMotionType_Static, LAYER_NON_MOVING);
				}
			}

			{
				// Create a push-able block
				const boxHalfExtent = 0.75;
				let shape = new Jolt.BoxShape(new Jolt.Vec3(boxHalfExtent, boxHalfExtent, boxHalfExtent));
				let creationSettings = new Jolt.BodyCreationSettings(
					shape, 
					new Jolt.Vec3(-10.0, 5.0, 10.0),
					new Jolt.Quat.prototype.sIdentity(), 
					Jolt.EMotionType_Dynamic, LAYER_MOVING
				);
				creationSettings.mFriction = 0.001;
				creationSettings.mOverrideMassProperties = Jolt.EOverrideMassProperties_CalculateInertia;
				creationSettings.mMassPropertiesOverride.mMass = 1;
				let body = bodyInterface.CreateBody(creationSettings);
				addToScene(body, 0x00ffff);
			}

			initShape();

			const settings = new Jolt.CharacterVirtualSettings();
			settings.mMass = 0;
			settings.mMaxSlopeAngle = maxSlopeAngle;
			settings.mMaxStrength = maxStrength;
			settings.mShape = standingShape;
			settings.mBackFaceMode = Jolt.EBackFaceMode_CollideWithBackFaces;
			settings.mCharacterPadding = characterPadding;
			settings.mPenetrationRecoverySpeed = penetrationRecoverySpeed;
			settings.mPredictiveContactDistance = predictiveContactDistance;
			settings.mSupportingVolume = new Jolt.Plane(Jolt.Vec3.prototype.sAxisY(), -characterRadiusStanding);
			character = new Jolt.CharacterVirtual(settings, Jolt.Vec3.prototype.sZero(), Jolt.Quat.prototype.sIdentity(), physicsSystem);
			character.SetListener(characterContactListener);

			threeCharacter.geometry = threeStandingGeometry;
			threeCharacter.userData.body = character;

			//scene.add(threeCharacter);

			const cameraRotation = new THREE.Quaternion();

			let players = []; 
    		players[0] = new Ent(THREE);

			onExampleUpdate = (time, deltaTime) => {
				if(config.Controller){
					if(Math.abs(analogMoveVertical) > config.Deadzone){
						input.vector.z = analogMoveVertical;
					} else {input.vector.z = 0;}

					if(Math.abs(analogMoveHorizontal) > config.Deadzone){
					  input.vector.x = analogMoveHorizontal;						
					} else {input.vector.x = 0;}

					euler.setFromQuaternion(camera.quaternion);

					if (Math.abs(analogLookHorizontal) > config.Deadzone){
						euler.y -= analogLookHorizontal * 2e-3 * config['Controller Sensitivity'];
					}
					if (Math.abs(analogLookVertical) > config.Deadzone){
  					euler.x -= analogLookVertical * 2e-3 * config['Controller Sensitivity'];
  					euler.x = Math.max((Math.PI / 2) - (Math.PI - 0.000000000000001), Math.min((Math.PI / 2) - 0.000000000000001, euler.x));
					}
  				camera.quaternion.setFromEuler(euler);
				}
				if(crouching || hasCrouched){
					input.position = new THREE.Vector3(threeCharacter.position.x,threeCharacter.position.y + 2,threeCharacter.position.z);
				} else {
					input.position = new THREE.Vector3(threeCharacter.position.x,threeCharacter.position.y + 1,threeCharacter.position.z);
				}
				input.hasCrouched = hasCrouched;
				input.position = new THREE.Vector3(threeCharacter.position.x,threeCharacter.position.y,threeCharacter.position.z);
				if(init){for (let i = 0; i < players.length; i++) {
        		  players[i].turn(input);
        		  turn(THREE, scene, dynamicObjects, camera, jolt, physicsSystem, input, players, init, bodyInterface, i, deltaTime);
      			  input.clickedLeft = false;
      			  input.clickedRight = false;
							input.init = false;
							input.contacts = [];
      				}
      			}
      			init = true;
      	input.grounded = character.GetGroundState() == Jolt.EGroundState_OnGround;
      	if(!(!input.crouched && !input.grounded)){
      		setCrouched(input.crouched);
      	}

      	if(unCrouchHeight > 0 && unCrouchHeight <= 1){
      		unCrouchHeight += 3.5 * deltaTime;
      		camera.position.set(camera.position.x, threeCharacter.position.y + 1 +unCrouchHeight, camera.position.z);
      	}

				camera.getWorldQuaternion(cameraRotation);
				const cameraDirectionV = new THREE.Vector3(input.vector.x, 0, input.vector.z).applyQuaternion(cameraRotation);
				cameraDirectionV.y = 0;
				cameraDirectionV.normalize().multiplyScalar(2);
				input.d = deltaTime;
				input.cameraDirection = camera.getWorldDirection(new THREE.Vector3(0,0,0));
				input.cameraPosition = wrapVec3(character.GetPosition())
				handleInput(cameraDirectionV, input.switchStance, input.collision.y, deltaTime);

				input.olderPosition = input.oldPosition;

				input.oldPosition = wrapVec3(character.GetPosition());
				prePhysicsUpdate(deltaTime)

				input.newdPosition = wrapVec3(character.GetPosition());
				camera.position.add(input.newdPosition.sub(input.oldPosition));
				input.collision.x = (players[0].translation.x - input.newdPosition.x);
				input.collision.y = (players[0].translation.y - input.newdPosition.y);
				input.collision.z = (players[0].translation.z - input.newdPosition.z);
				input.collision.length = new THREE.Vector2(input.collision.x,input.collision.z).length();
				if(document.fullscreenElement !== null && !pointer.isLocked){pointer.lock();}
			}
			document.addEventListener("keydown", onDocumentKeyDown, false);
			document.addEventListener("keyup", onDocumentKeyUp, false);
			document.addEventListener('mousemove', function (evt) {
  				input.lastMouseMove = performance.now();
  				input.mouseMoveX = evt.movementX;
			});
	const pointer = new PointerLockControls( camera, container );
	pointer.pointerSpeed = 2.19/4;
	pointer.maxPolarAngle = Math.PI - 0.000000000000001;
	pointer.minPolarAngle = 0.000000000000001;

	//localStorage.removeItem('config');
	//localStorage.removeItem('configVersion');

	var configVersion = 0;

	if (localStorage.getItem('configVersion') === null){
	  localStorage.setItem('configVersion', configVersion);
	}

	const defaultBind = {
	  Forward: 'w',
	  Left: 'a',
	  Back: 's',
	  Right: 'd',
	  Jump: ' ',
	  Crouch: 'shift',
	};
	const defaultControllerBind = {
	  Jump: 'button_0',
	  Crouch: 'button_1',
	};
	var bind = defaultBind;

	var gui = new GUI();

	var guiBind = defaultBind;

	const defaultConfig = {
		Sensitivity: 2.19,
		FPS: true,
		Controller: false,
		Deadzone: 0.06,
		'Controller Sensitivity': 10.00,
		bind: defaultBind,
		controllerBind: defaultControllerBind,
		Default: function() {
	  	  config = JSON.parse(JSON.stringify(defaultConfig));
	  	  localStorage.setItem('config', JSON.stringify(config));
	  	  initGui();
		},
	};
	const initGui = function(){
			gui.destroy();
			gui = new GUI();
			gui.add( config, 'Sensitivity', 0, 10 );
			gui.add( config, 'FPS' );
			gui.add( config, 'Controller' );
			gui.add( config, 'Controller Sensitivity', 0, 100 );
			gui.add( config, 'Deadzone' );

			const bindFolder = gui.addFolder( 'Bindings' );
			Object.keys(config.bind).forEach(key => {
		  	  bindFolder.add( config.bind, key);
			});
			const controllerBindFolder = gui.addFolder( 'Controller Bindings' );
			Object.keys(config.controllerBind).forEach(key => {
		  	  controllerBindFolder.add( config.controllerBind, key);
			});
			config.Default = defaultConfig.Default;
		    gui.add( config, 'Default' ); // Button
			gui.domElement.style.backgroundColor = '#17191a00';
			gui.domElement.childNodes[0].style.backgroundColor = '#17191a00';
			gui.domElement.style.mixBlendMode = 'difference';
			gui.domElement.style.right = '0';
			if(config.FPS){
    		stats.domElement.style.opacity = '.5';
    	} else {
    		stats.domElement.style.opacity = '0';
    	}


			gui.onChange( event => {
			  if (event.controller.parent._title == 'Bindings'){
			  	Object.keys(config.bind).forEach(key => {
			  	  config.bind[key] = config.bind[key].toLowerCase();
			  	});
			  } else switch (event.property) {
		  		case 'Sensitivity':
		    	  pointer.pointerSpeed = event.value/4;
		    	  break;
		    	case 'FPS':
		    		if (config.FPS){
		    			stats.domElement.style.opacity = '.5';
		    		} else {
		    			stats.domElement.style.opacity = '0';
		    		}
		    		break;
		    	case 'Controller':
		    		break;
		    	case 'Controller Sensitivity':
		    		break;
		    	case 'Deadzone':
		    		break;
		    }
				localStorage.setItem('config', JSON.stringify(config));
			  localStorage.setItem('configVersion', configVersion);

			  //event.object     // object that was modified
			  //event.property   // string, name of property
			  //event.value      // new value of controller
			  //event.controller // controller that was modified
			} );
	};
    var config = JSON.parse(JSON.stringify(defaultConfig));

    if (localStorage.getItem('config') === null || localStorage.getItem('configVersion') !== configVersion.toString()) {
      localStorage.removeItem('config');
    } else {
    	config = JSON.parse(localStorage.getItem('config'));
    	pointer.pointerSpeed = config.Sensitivity/4;
    }

    initGui();

  if(Object.hasOwn(joypad, 'set')){
	  joypad.set({
	  	axisMovementThreshold: 0,
		});

		joypad.on('connect', (e) => {
	  	const { id } = e.gamepad;

	  	console.log(`${id} connected!`);

		});

		joypad.on('axis_move', (e) => {
	  	  //console.log(e.detail);
	  		analogMoveHorizontal = e.detail.gamepad.axes[0];
	  		analogMoveVertical = e.detail.gamepad.axes[1];
	  		analogLookHorizontal = e.detail.gamepad.axes[2];
	  		analogLookVertical = e.detail.gamepad.axes[3];
		});

		joypad.on('button_press', (e) => {
	  	const { buttonName } = e.detail;
	  	switch (e.detail.buttonName){
	  		case config.controllerBind.Jump:
	  			jump = true;
	  			break;
	  		case config.controllerBind.Crouch:
	  			input.crouched = true;
	  			break;
	  	}

	  	if(!(document.getSelection().focusNode === null)){
	  		if(document.getSelection().focusNode.parentElement.className == 'controller string'){
	  			document.execCommand("selectAll", false);
	  			document.execCommand("delete", false);
	  			document.execCommand("insertText", false, e.detail.buttonName);
	  		}
	  	}
		});

		joypad.on('button_release', (e) => {
	  	const { buttonName } = e.detail;
	  	switch (e.detail.buttonName){
	  		case config.controllerBind.Jump:
	  			jump = false;
	  			break;
	  		case config.controllerBind.Crouch:
	  			input.crouched = false;
	  			break;
	  	}
		});
  }

	addEventListener("mousedown", (event) => {
    if(pointer.isLocked){
      if(event.button == 0){
        input.clickedLeft = true;
      }
      if(event.button == 2){
        input.clickedRight = true;
      }
	} else if('[object HTMLCanvasElement]' == event.target.toString()) {container.requestFullscreen() ;}
	});
			function onDocumentKeyDown(event) {
				var key = event.key.toLowerCase();
				if (key == config.bind.Forward) {
					input.forwardPressed = true; input.vector.z = -1;
				} else if (key == config.bind.Back) {
					input.backwardPressed = true; input.vector.z = 1;
				} else if (key == config.bind.Left) {
					input.leftPressed = true; input.vector.x = -1;
				} else if (key == config.bind.Right) {
					input.rightPressed = true; input.vector.x = 1;
				} else if (key == config.bind.Jump) {
					jump = true;
				} else if (key == config.bind.Crouch) {
					input.crouched = true;
				}
			};
			function onDocumentKeyUp(event) {
				var key = event.key.toLowerCase();
				if (key == config.bind.Forward) {
					input.forwardPressed = false;
					if (!input.backwardPressed){input.vector.z = 0;} else {input.vector.z = 1;}
				} else if (key == config.bind.Back) {
					input.backwardPressed = false;
					if (!input.forwardPressed){input.vector.z = 0;} else {input.vector.z = -1;}
				} else if (key == config.bind.Left) {
					input.leftPressed = false;
					if (!input.rightPressed){input.vector.x = 0;} else {input.vector.x = 1;}
				} else if (key == config.bind.Right) {
					input.rightPressed = false;
					if (!input.leftPressed){input.vector.x = 0;} else {input.vector.x = -1;}
				} else if (key == config.bind.Jump) {
					jump = false;
				} else if (key == config.bind.Crouch) {
					input.crouched = false;
				}
			};
			addEventListener("blur", (event) => {
				input.forwardPressed = false;
				input.backwardPressed = false;
				input.leftPressed = false;
				input.rightPressed = false;
				input.crouched = false;
				input.vector.z = 0;
				input.vector.x = 0;
			});

			physicsSystem.SetGravity(new Jolt.Vec3(0, -28, 0));
		}
		});

	</script>
</body>
</html>